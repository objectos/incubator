= The `include` instruction

The `JavaTemplate` class provides a template system for generating Java files.
Being a regular Java class itself, the `JavaTemplate` allows you to use Java constructs in your template.

In other words, instead of writing something like the following:

----
{{#fields}}
private static final {{type}} {{name}};
{{/fields}}
----

You would use a plain Java `for` loop:

[,java]
----
for (var field : fields) {
  code(
    _private(), _static(), _final(), 
    t(field.type), id(field.name)
  );
}
----

To achieve this, the `JavaTemplate` provides the `include` instruction.

== Generating code based on the elements of a collection

Suppose you need to generate a Java class file similar to the following:

[,java]
----
public enum Tag {
  A("a"),

  DIV("div"),

  LI("li"),

  TABLE("table"),

  UL("ul");

  private final String name;

  private Tag(String name) {
    this.name = name;
  }
}
----

It is an enum class representing a few of the HTML tags.

Suppose now that the names of the tags come from an external source.
In other words, the programmer does not know in advance how many names there will be.

The following `JavaTemplate` declares a `Set` to hold (and sort) the names of the tags.
Then, it uses an `include` instruction to iterate over the elements of the set and generate the enum constants:

[,java]
----
import java.util.Set;
import java.util.TreeSet;
import objectos.code.JavaTemplate;

public class TagTemplate extends JavaTemplate {
  private final Set<String> tagNames = new TreeSet<>();

  public final void add(String name) {
    tagNames.add(name);
  }

  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");

    autoImports();

    _public(); _enum("Tag"); body(
      include(this::constants),

      _private(), _final(), t(String.class), id("name"),

      _private(), constructor(t(String.class), id("name")), block(
        _this(), n("name"), gets(), n("name")
      )
    );
    // @formatter:on
  }

  private void constants() {
    for (var tagName : tagNames) {
      var fieldName = tagName.toUpperCase();

      enumConstant(fieldName, s(tagName));
    }
  }
}
----

Notice how an `include` instruction is declared inside the `body` of the `_enum`.
It then can be used like the following:

[,java]
----
var tmpl = new TagTemplate();

tmpl.add("div");
tmpl.add("a");
tmpl.add("ul");
tmpl.add("li");
tmpl.add("table");

System.out.println(tmpl.toString());
----

Which generates the enum listed at the beginning of this section.

== Conditionally generating a construct

You can use the `include` instruction to conditionally generate a construct.

Consider the following template:

[,java]
----
import objectos.code.JavaTemplate;

public class Condition extends JavaTemplate {
  boolean generate;

  @Override
  protected final void definition() {
    // @formatter:off
    _class("Condition"); body(
      _abstract(), _void(), method("foo", include(this::parameters))
    );
    // @formatter:on
  }

  private void parameters() {
    code(_int(), id("always"));

    if (generate) {
      code(_int(), id("maybe"));
    }
  }
}
----

It generates a class named `Condition` containing a single abstract method named `foo`.

The `foo` method declaration contains an `include` instruction:

[,java]
----
method("foo", include(this::parameters))
----

The `include` delegates the method's formal parameters declaration to the `parameters` private method:

[,java]
----
private void parameters() {
  code(_int(), id("always"));

  if (generate) {
    code(_int(), id("maybe"));
  }
}
----

The `parameters` method may generate one or two `int` parameters:

* the `always` parameter is always generated; and
* the `maybe` parameter is generated depending on the value of the `generate` instance variable.

The following illustrates the conditional generation of the `maybe` parameter:

[,java]
----
var tmpl = new Condition();

tmpl.generate = false;

System.out.println(tmpl);

tmpl.generate = true;

System.out.println(tmpl);
----

Which prints:

[,java]
----
class Condition {
  abstract void foo(int always);
}

class Condition {
  abstract void foo(int always, int maybe);
}
----