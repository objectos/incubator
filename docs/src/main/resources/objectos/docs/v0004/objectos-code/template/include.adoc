= The `include` instruction

You declare the source code to be generated in a `JavaTemplate` class.
A `JavaTemplate` instance represents a Java compilation unit.

You use it by extending it and implementing the `definition` method.
Use the provided _embedeed domain-specific language_ in the latter to declare the contents of the Java file you want to generate:

[,java]
----
import objectos.code.JavaTemplate;

public class MyTemplate extends JavaTemplate {
  @Override
  protected final void definition() {
    _package("com.example");

    autoImports();

    _public();
    _class("Empty");
    body();
  }
} 
----

Which can be used to generate the following Java code:

[,java]
----
package com.example;

public class Empty {}
----

Let's discuss some of its features.

== Features

The `JavaTemplate` class provides the programmer with two features:

- import declarations are automatically generated; and
- allow for control flow via the `include` instruction.

=== The `autoImports` instruction

Consider the following template that generates a `AutoImports` class containing two fields: 

[,java]
----
import java.io.IOException;
import java.util.List;
import objectos.code.JavaTemplate;

public class AutoImportsOn extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");

    autoImports();

    _public(); _class("AutoImports"); body(
      t(t(List.class), t(IOException.class)), id("a"),

      t(String.class), id("b")
    );
  }
}
----

Notice that the `autoImports` instruction is enabled.
It generates the following Java code:

[,java]
----
package com.example;

import java.io.IOException;
import java.util.List;

public class AutoImports {
  List<IOException> a;

  String b;
}
----

Notice that the import declarations were generates.
On the other hand, if we omit the `autoImports` instruction, like so:

[,java]
----
_package("com.example");

_public(); _class("AutoImports"); body(
  t(t(List.class), t(IOException.class)), id("a"),

  t(String.class), id("b")
);
----

Then the following is generated:

[,java]
----
package com.example;

public class AutoImports {
  java.util.List<java.io.IOException> a;

  java.lang.String b;
}
----

Notice how _all_ types are declared in their fully qualified names,
including the ones from the `java.lang` package.

=== The `autoImports` and name conflicts

In the case of conflict, the first type declared is imported.
Any subsequent type is declare in its fully qualified name.

To illustrate consider the following example:

[,java]
----
_package("com.example");

autoImports();

_public(); _class("AutoImports"); body(
  t(t(java.awt.List.class), t(String.class)), id("a"),

  t(t(java.util.List.class), t(String.class)), id("b"),

  t(t("com.example", "List"), t(String.class)), id("c")
);
----

It declares three `List` fields.
However, each `List` type is of a different package.

The code above generates the following:

[,java]
----
package com.example;

import java.awt.List;

public class AutoImports {
  List<String> a;

  java.util.List<String> b;

  com.example.List<String> c;
}
----

So the first `List` encountered is imported.
The remaining ones are declared in full name. 

=== The `include` instruction

TODO

== Recommended usage

TODO

=== Instances are meant to be reused (in a single-threaded environment) 

TODO

=== It should have all the data

TODO

== Where to go from here?

TODO