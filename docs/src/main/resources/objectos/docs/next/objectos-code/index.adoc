= Objectos Code
:toc-title: Overview

Objectos Code is a library for generating Java source code.

It introduces the concept of a "pure Java template";
it feels like a traditional text-based template except it is a regular Java class.

== Tutorial

This tutorial will give you an introduction on how to generate Java source code using Objectos Code.

=== An empty class

Let's start by generating a class that has an empty body.
In other words, we want to generate the following:

[,java]
----
class Tutorial {}
----

To use Objectos Code you have to:

- extend the `JavaTemplate` class; and
- provide the implementation of the `definition` method.

In the body of latter, you use the provided _embedded domain-specific language_ to define the Java file you will generate.
Like so:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    _class("Tutorial");
    body();
  }
}
----

It starts by invoking the `_class` method.
Notice that, as `class` is a reserved keyword in Java, the method name starts with the '_' (underscore) character.
The string `"Tutorial"`, the name of the class we want to generate, is passed as the argument to the `_class` method.

Next, we invoked the `body` method.
No arguments were passed as we want to generate a class with an empty body.

Right.
Let's move to the next step.

=== The package declaration

Let's add a package declaration to our generated Java source file.
We want our class to be in the `com.example` package, like so:

[,java]
----
package com.example;

class Tutorial {}
----

In our template, we invoke the `_package` method:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    _package("com.example");
  
    _class("Tutorial");
    body();
  }
}
----

Once again, the `_package` method name begins with an underscore character.

=== The class modifiers

Let's add modifiers to our class.

We want the generated class to be the following:

[,java]
----
package com.example;

public final class Tutorial {}
----

Our class is now both `public` and `final`.
So we need to add the same "keywords" to our template: 

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    _package("com.example");

    _public();
    _final();
    _class("Tutorial");
    body();
  }
}
----

With each "keyword" sitting at a different line, our template does not look like a regular Java file.
Let's improve that.

=== Optional: the `code` method

We can group all of our template instructions in a single `code` method invocation like so:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    code(
      _package("com.example"),

      _public(), _final(), _class("Tutorial"), body()
    );
  }
}
----

Notice that the instructions are now arguments to the `code` method.
Therefore, each instruction is now separated with a comma.

Alternatively, you can use a `@formatter:off` comment tag to turn off your IDE code formatter:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");

    _public(); _final(); _class("Tutorial"); _body();
  }
}
----

This tutorial will use the latter form from now on.

=== Annotations

Let's annotate our class with a hypothetical `Subject` annotation:

[,java]
----
package com.example;

import com.example.annotations.Subject;

@Subject("Objectos Code")
public final class Tutorial {}
----

The annotation is declared at a different package than our class.
Therefore, we also need to add an import declaration.

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");
    
    autoImports();

    at(t("com.example.annotations", "Subject"), s("Objectos Code"));
    _public(); _final(); _class("Tutorial"); _body();
  }
}
----

The `autoImports` instruction will automatically add any required import declaration.
Please note that it *must* be declared after the package declaration and before the first top level declaration.

The `at` method was used to annotate our class declaration:

* the `t` method defines the annotation type; and
* the `s` method declares the `"Objectos Code"` string literal.

=== A field

Let's now add a single field to our class.
It should look like the following:

[,java]
----
package com.example;

import com.example.annotations.Subject;

@Subject("Objectos Code")
public final class Tutorial {
  private final int value;
}
----

As it is, this Java code would not compile.

Don't worry, we will add a constructor as our next step.

But, for now, we want to focus on adding the `int` field.
So we modify our template to the following:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");
    
    autoImports();

    at(t("com.example.annotations", "Subject"), s("Objectos Code"));
    _public(); _final(); _class("Tutorial"); _body(
      _private(), _final(), _int(), id("value")
    );
  }
}
----

So for our field declaration:

- the modifiers are given by the `_private()` and `_final()` methods;
- the type is given by the `_int()` method; and
- the name is given by the `id("value")` method.

Note that, in this particular case, the semicolon after the field is added automatically.

=== A constructor

Let's add a constructor next.
We want the generated Java code to be the following:

[,java]
----
package com.example;

import com.example.annotations.Subject;

@Subject("Objectos Code")
public final class Tutorial {
  private final int value;
  
  public Tutorial(int value) {
    this.value = value;
  }
}
----

Let's modify our `JavaTemplate` so it generates the constructor:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");
    
    autoImports();

    at(t("com.example.annotations", "Subject"), s("Objectos Code"));
    _public(); _final(); _class("Tutorial"); _body(
      _private(), _final(), _int(), id("value"),
      
      _public(), constructor(_int(), id("value")), block(
        _this(), n("value"), gets(), n("value")
      )
    );
  }
}
----

Let's see how this works.

* notice that the `constructor` method is being invoked.
It automatically add the enclosing type's simple name, `Tutorial` in our example, as the constructor's name;
* the `constructor` method arguments define the parameter of our constructor.
In other words, the `_int()` and the `_id("value")` arguments, generate the `int value` formal parameter;
* next, a `block` method is invoked.
It represents the constructors' body;
* finally, the assignment expression statement.
Notice how the expression name `n("value")` is automatically connected to the keyword `_this()`.
The `gets()` method represents the simple assignment operator, i.e. the `=` (equals sign) operator.

=== A method

And so we update our template to the following:

[,java]
----
import objectos.code.JavaTemplate;

public class Tutorial extends JavaTemplate {
  @Override
  protected final void definition() {
    // @formatter:off
    _package("com.example");
    
    autoImports();

    at(t("com.example.annotations", "Subject"), s("Objectos Code"));
    _public(); _final(); _class("Tutorial"); _body(
      _private(), _final(), _int(), id("value"),
      
      _public(), constructor(_int(), id("value")), block(
        _this(), n("value"), gets(), n("value")
      ),
      
      _public(), _int(), method("get"), block(
        _return(), n("value")
      )
    );
  }
}
----

== Installation

To use Objectos Code in your project add the following to your POM:

[,xml]
----
<dependencies>
    <dependency>
        <groupId>br.com.objectos</groupId>
        <artifactId>objectos-code</artifactId>
    </dependency>
</dependencies>
----

This assumes you are using the ilink:intro/install[Objectos BOM POM].
